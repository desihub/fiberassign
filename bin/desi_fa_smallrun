#!/usr/bin/env python

import os
import sys
from glob import glob
import numpy as np
import astropy.io.fits as fits
from astropy.table import Table, vstack
from astropy import units
from astropy.coordinates import SkyCoord
import fitsio
from datetime import datetime, timezone
from time import time

# AR desitarget
import desitarget
from desitarget.targets import encode_targetid
from desitarget.targetmask import obsconditions
from desitarget.io import read_targets_in_tiles
from desitarget.geomask import match  # AR to match arrays with no repeats
from desitarget.mtl import make_mtl, calc_priority
from desitarget.internal import sharedmem

# AR fiberassign
import fiberassign
from fiberassign.scripts.assign import parse_assign, run_assign_full
from fiberassign.utils import Logger, assert_isoformat_utc
from fiberassign.fba_launch_io import get_desitarget_paths

# AR desimodel
import desimodel
from desimodel.footprint import is_point_in_desi, tiles2pix
from desiutil.redirect import stdouterr_redirected
import healpy as hp
from argparse import ArgumentParser


# AR created file names
def get_fn(outdir, flavor, passid=None, steps=None):
    # AR flavor = settings, log, tiles, sky, targ, fastats-targ, fastats-sky
    # AR pass = passid
    if passid is not None:
        if flavor == "tiles":
            fn = os.path.join(
                outdir,
                "faruns",
                "farun-pass{}".format(passid),
                "{}-pass{}.fits".format(flavor, passid),
            )
        if flavor == "targ":
            fn = os.path.join(
                outdir, "outputs", "{}-after-pass{}.fits".format(flavor, passid)
            )
    elif flavor == "settings":
        fn = os.path.join(outdir, "inputs", "{}-settings.asc".format(steps.replace(",", "-")))
    elif flavor == "log":
        fn = os.path.join(outdir, "outputs", "{}.log".format(steps.replace(",", "-")))
    elif flavor in ["fastats-targ", "fastats-sky", "fastats-pairs"]:
        fn = os.path.join(outdir, "outputs", "{}.asc".format(flavor))
    else:
        fn = os.path.join(outdir, "inputs", "{}.fits".format(flavor))
    return fn


# AR creates one tiles file for with all passes
# AR and one tiles file per pass
# AR formatting assumed to be that of tiles-main.ecsv
# AR for that file, dark, bright, backup have the same
# AR tile centers for a given pass
# AR so we just work from the 7 dark passes
# AR and change the PROGRAM value
def create_tiles(infn, program, radec, outdir):
    d_orig = Table.read(infn)
    # AR cut on the 7 dark passes, irrespective of args.program
    # AR protecting against upper/lower case, if using files like 4112-packing
    keep = np.array([program.lower() for program in d_orig["PROGRAM"]]) == "dark"
    d_orig = d_orig[keep]
    # AR
    d = Table()
    for key in d_orig.dtype.names:
        d[key] = d_orig[key]
    # AR update PROGRAM with args.program, and add OBSCONDITIONS
    d["PROGRAM"] = args.program
    d["OBSCONDITIONS"] = obsconditions.mask(args.program.upper())
    # AR populate TILEID with CENTERID
    # AR in case using like tiles-4112-packing-20210329-decorated.fits)
    if len(np.unique(d["TILEID"])) == 1:
        d["TILEID"] = d["CENTERID"].copy()
    # AR cut on IN_DESI
    is_indesi = d["IN_DESI"]
    # AR cut on radec
    ramin, ramax, decmin, decmax = [float(x) for x in radec.split(",")]
    is_radec = (d["DEC"] > decmin) & (d["DEC"] < decmax)
    if ramax < ramin:
        is_radec &= (d["RA"] > ramin) | (d["RA"] < ramax)
    else:
        is_radec &= (d["RA"] > ramin) & (d["RA"] < ramax)
    # AR cut on the number of passes (first pass is 0)
    if args.npass > d["PASS"].max() + 1:
        log.error(
            "{:.1f}s\tcreate_tiles\tWARNING : requesting {} passes, whereas only {} passes available".format(
                time() - start, args.npass, d["PASS"].max() + 1
            )
        )
        sys.exit(1)
    is_pass = d["PASS"] + 1 <= args.npass
    # AR writing one tiles file with all passes
    keep = (is_indesi) & (is_radec) & (is_pass)
    d = d[keep]
    fitsio.write(get_fn(args.outdir, "tiles"), d.as_array(), clobber=True)
    # AR writing one tiles file for each pass
    passids = np.unique(d["PASS"])
    for passid in passids:
        d = fitsio.read(get_fn(args.outdir, "tiles"))
        keep_p = d["PASS"] == passid
        log.info(
            "{:.1f}s\tcreate_tiles\tpass = {} -> {} tiles".format(
                time() - start, passid, keep_p.sum()
            )
        )
        d = d[keep_p]
        fadir = os.path.join(args.outdir, "faruns", "farun-pass{}".format(passid))
        if not os.path.isdir(fadir):
            os.mkdir(fadir)
        fitsio.write(get_fn(args.outdir, "tiles", passid=passid), d, clobber=True)
    return True


# AR wrapper to read targets
def wrapper_read_targets():
    tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
    mydirs = get_desitarget_paths(args.dtver, args.survey, args.program, dr=args.dr, log=log)
    # AR we only store some columns to save disk storage...
    # AR and those columns are both in resolve and secondary desitarget fits files
    # AR except BGS_TARGET and MWS_TARGET, which complement with zeros
    keys = ["TARGETID", "RA", "DEC"]
    keys += [
        dtkey,
        dtkey.replace("DESI", "BGS"),
        dtkey.replace("DESI", "MWS"),
        dtkey.replace("DESI", "SCND"),
    ]
    keys += [
        "SUBPRIORITY",
        "OBSCONDITIONS",
        "PRIORITY_INIT",
        "NUMOBS_INIT",
    ]
    # AR primary
    log.info("{:.1f}s\twrapper_read_targets\thpdir={}".format(time() - start, mydirs["targ"]))
    log.info("{:.1f}s\twrapper_read_targets\tkeys={}".format(time() - start, keys))
    prim = Table(read_targets_in_tiles(mydirs["targ"], tiles, columns=keys, quick=True))
    log.info("{:.1f}s\twrapper_read_targets\tread {} targets".format(time() - start, len(prim)))
    # AR secondaries, also parsing scnd2, etc
    dirkeys = [key for key in mydirs if key[:4] == "scnd" and key != "scndmtl"]
    scnds = []
    for dirkey in dirkeys:
        tmpkeys = [key for key in keys if key in fits.open(mydirs[dirkey])[1].columns.names]
        addkeys = [key for key in keys if key not in tmpkeys]
        log.info("{:.1f}s\twrapper_read_targets\thpdir={}".format(time() - start, mydirs[dirkey]))
        log.info("{:.1f}s\twrapper_read_targets\tkeys={}".format(time() - start, tmpkeys))
        log.info("{:.1f}s\twrapper_read_targets\tadding zeros for {}".format(time() -start, addkeys))
        d = Table(read_targets_in_tiles(mydirs[dirkey], tiles, columns=tmpkeys, quick=False))
        log.info("{:.1f}s\twrapper_read_targets\tread {} targets".format(time() - start, len(d)))
        for key in addkeys:
            d[key] = np.zeros(len(d), dtype=prim[key].dtype)
        scnds.append(d)
    # AR stacking primary + secondaries
    d = vstack([prim] + scnds)
    log.info("{:.1f}s\twrapper_read_targets\tread {} prim+secondary targets".format(time() - start, len(d)))
    # AR changing NUMOBS_INIT?
    # AR e.g. if sv3, change NUMOBS_INIT=9 to NUMOBS_INIT=1 or 3
    # AR see https://desi.lbl.gov/trac/wiki/TargetSelectionWG/MTL#DarkTime1
    if args.numobs_init_notqso is not None:
        keep = ((d[dtkey] & desi_mask["QSO"]) == 0) & (d["NUMOBS_INIT"] != -1)
        d["NUMOBS_INIT"][keep] = args.numobs_init_notqso
        log.info(
            "{:.1f}s\twrapper_read_targets\tforcing NUMOBS_INIT={} for {}/{} targets which are not QSO".format(
                time() - start, args.numobs_init_notqso, keep.sum(), len(d)
            )
        )
    if args.numobs_init_qso is not None:
        keep = ((d[dtkey] & desi_mask["QSO"]) > 0) & (d["NUMOBS_INIT"] != -1)
        d["NUMOBS_INIT"][keep] = args.numobs_init_qso
        log.info(
            "{:.1f}s\twrapper_read_targets\tforcing NUMOBS_INIT={} for {}/{} targets which are not QSO".format(
                time() - start, args.numobs_init_qso, keep.sum(), len(d)
            )
        )
    return d


# AR wrapper to read randoms
def wrapper_read_randoms():
    tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
    # AR all sky 2500/deg2 random file
    fn = os.path.join(
        os.getenv("DESI_ROOT"),
        "target/catalogs/dr9/0.49.0/randoms/resolve/randoms-allsky-1-0.fits",
    )
    # AR healpix settings
    log.info("{:.1f}s\twrapper_read_randoms\tstart".format(time() - start))
    hdr = fits.getheader(fn, 1)
    nside, nest = hdr["HPXNSIDE"], hdr["HPXNEST"]
    rand_dens = hdr["DENSITY"]
    # AR hp pixels touching the tiles
    pixlist = tiles2pix(nside, tiles=tiles)
    # AR reading the hpxpixel
    d = fitsio.read(fn, columns=["HPXPIXEL"])
    log.info("{:.1f}s\twrapper_read_randoms\tfirst read done".format(time() - start))
    # AR cutting on rands touching pixlist
    rows = np.where(np.in1d(d["HPXPIXEL"], pixlist))[0]
    d = fitsio.read(fn, columns=["RA", "DEC", "BRICKID"], rows=rows)
    log.info("{:.1f}s\twrapper_read_randoms\tsecond read done".format(time() - start))
    # AR properly cutting on the tiles footprint
    keep = is_point_in_desi(tiles, d["RA"], d["DEC"])
    d = d[keep]
    ras, decs, brickids = d["RA"], d["DEC"], d["BRICKID"]
    nrand = len(ras)
    # AR creating fake columns
    log.info("{:.1f}s\twrapper_read_randoms\tstart build table".format(time() - start))
    d = Table()
    d["TARGETID"] = encode_targetid(objid=np.arange(nrand), brickid=brickids)
    d["RA"], d["DEC"] = ras, decs
    d[dtkey] = np.zeros(nrand, dtype=int) + desi_mask["ELG"] # AR making them ELGs
    d[dtkey.replace("DESI", "BGS")] = np.zeros(nrand, dtype=int)
    d[dtkey.replace("DESI", "MWS")] = np.zeros(nrand, dtype=int)
    d["PRIORITY_INIT"] = (
        np.zeros(nrand, dtype=int) + desi_mask["ELG"].priorities["UNOBS"]
    )
    d["SUBPRIORITY"] = np.random.uniform(low=0, high=1, size=nrand)
    d["NUMOBS_INIT"] = np.ones(nrand, dtype=int)
    d["OBSCONDITIONS"] = np.array([args.program.upper() for x in ras])
    log.info("{:.1f}s\twrapper_read_randoms\tdone build table".format(time() - start))
    return d, rand_dens


# AR randomly assigns QSO to be Lya
def set_lya(d, lyafrac):
    ii_qso = np.where((d[dtkey] & desi_mask["QSO"]) > 0)[0]
    ii_lya = np.random.choice(ii_qso, size=int(lyafrac * len(ii_qso)), replace=False)
    return np.in1d(np.arange(len(d), dtype=int), ii_lya)


# AR tweak PRIORITY_INIT and PRIORITY
def tweak_priority(d, priority_mask, priority_frac, priority_new):
    # AR to store the targets with tweaked priority
    ii_used = []
    for pm, pf, pn in zip(
        priority_mask.split(","), priority_frac.split(","), priority_new.split(",")
    ):
        ii = np.where((d[dtkey] & desi_mask[pm]) > 0)[0]
        n_tweak = int(len(ii) * float(pf))
        ii_avail = ii[~np.in1d(ii, ii_used)]
        if len(ii_avail) < n_tweak:
            log.error(
                "cannot force {}/{} {} targets to PRIORITY={}; exiting".format(
                    n_tweak, len(ii_avail), pm, pn
                )
            )
            sys.exit()
        log.info(
            "{:.1f}s\ttweak_priority\tforcing {}/{} {} targets to PRIORITY={}".format(
                time() - start, n_tweak, len(ii_avail), pm, pn
            )
        )
        ii_tweak = np.random.choice(ii_avail, size=n_tweak, replace=False)
        d["PRIORITY_INIT"][ii_tweak] = np.clip(
            d["PRIORITY_INIT"][ii_tweak], int(pn), None
        )
        d["PRIORITY"][ii_tweak] = np.clip(d["PRIORITY"][ii_tweak], int(pn), None)
        ii_used += ii_tweak.tolist()
    return d


# AR sky file
def create_sky(footfn, skyfn):
    # AR sky folders
    mydirs = get_desitarget_paths(args.dtver, args.survey, args.program, dr=args.dr, log=log)
    skydirs = [mydirs["sky"]]
    if os.path.isdir(mydirs["skysupp"]):
        skydirs.append(mydirs["skysupp"])
    # AR we only store some columns
    columns = [
        "RA",
        "DEC",
        "TARGETID",
        "DESI_TARGET",
        "BGS_TARGET",
        "MWS_TARGET",
        "SUBPRIORITY",
        "OBSCONDITIONS",
        "PRIORITY_INIT",
        "NUMOBS_INIT",
    ]
    # AR we read
    tiles = fits.open(footfn)[1].data
    ds = [read_targets_in_tiles(skydir, tiles=tiles, columns=columns, quick=True) for skydir in skydirs]
    for skydir, d in zip(skydirs, ds):
        log.info("{:.1f}s\tcreate_sky\t{}: reading {} targets from {}".format(time() - start, os.path.basename(footfn), len(d), skydir))
    d = np.concatenate(ds)
    fitsio.write(skyfn, d, clobber=True)
    return True


# AR internal function to run fiber assignment
# AR on a tile, when args.numproc > 1
# AR uses global variables:
# AR - targ_ra, targ_dec : input target coordinates
def _do_run_assign_full(intargfn_fadir_footfn_skyfn_targfn):
    global targ_ra, targ_dec
    # AR decode folder/filenames
    intargfn, fadir, footfn, skyfn, targfn = intargfn_fadir_footfn_skyfn_targfn.split(
        ","
    )
    # AR sky
    _ = create_sky(footfn, skyfn)
    # AR targ
    ii = np.where(is_point_in_desi(fits.open(footfn)[1].data, targ_ra, targ_dec))[0]
    d = fitsio.read(intargfn, rows=ii)
    fitsio.write(targfn, d, clobber=True)
    # AR run fiber assignment
    opts = [
        "--rundate",
        args.rundate,
        "--overwrite",
        "--write_all_targets",
        "--footprint",
        footfn,
        "--dir",
        fadir,
        "--sky",
        skyfn,
        "--targets",
        targfn,
        "--sky_per_petal",
        args.sky_per_petal,
        "--standards_per_petal",
        args.standards_per_petal,
        "--sky_per_slitblock",
        str(args.sky_per_slitblock),
        "--margin-pos",
        str(args.margin_pos),
        "--margin-gfa",
        str(args.margin_gfa),
        "--margin-petal",
        str(args.margin_petal)
    ]
    log.info(
        "{:.1f}s\t_do_run_assign_full\trun_assign_full for {}".format(
            time() - start, targfn
        )
    )
    ag = parse_assign(opts)
    run_assign_full(ag)
    # AR clean input files
    for fn in [footfn, skyfn, targfn]:
        os.remove(fn)
    return True


# AR update the catalogs after having run fa + stats
def update_after_farun(input_targ, fadir, passid, output_targ):
    # fba files
    fns = np.sort(glob(os.path.join(fadir, "fba-??????.fits")))
    # reading targ which received a fibre, targ available
    # std, sky
    samples = ["targ", "targets", "potential", "sky"]
    extnames = ["FASSIGN", "FTARGETS", "FAVAIL", "FASSIGN"]
    myd = {}
    for sample, extname in zip(samples, extnames):
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\treading {}".format(
                time() - start, passid, sample
            )
        )
        # AR reading
        myd[sample] = vstack(
            [Table.read(fn, hdu=extname) for fn in fns], metadata_conflicts="silent"
        )
        # AR cutting
        if sample in ["targ", "targets"]:
            keep = (myd[sample]["FA_TYPE"] & 1) > 0
        elif sample == "sky":
            keep = (myd[sample]["FA_TYPE"] & 4) > 0
        elif sample == "potential":
            keep = np.ones(len(myd[sample]), dtype=bool)
        else:
            log.error("wrong sample! exiting")
            sys.exit()
        myd[sample] = myd[sample][keep]
        # AR writing
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\tbuilding+writing {}".format(
                time() - start, passid, sample
            )
        )
        fitsio.write(
            os.path.join(fadir, "fba-{}-pass{}.fits".format(sample, passid)),
            myd[sample].as_array(),
            clobber=True,
        )
    # AR input TARGETID, NUMOBS_MORE, NUMOBS_DONE
    log.info(
        "{:.1f}s\tupdate_after_farun\tpassid={}\treading {}".format(
            time() - start, passid, input_targ
        )
    )
    h = fits.open(input_targ)
    tids = np.array(myd["targ"]["TARGETID"])
    tids, counts = np.unique(tids, return_counts=True)
    ii0, ii1 = match(h[1].data["TARGETID"], tids)
    # AR updating numobs_more
    h[1].data["NUMOBS_MORE"][ii0] -= counts[ii1]
    h[1].data["NUMOBS_MORE"] = np.clip(h[1].data["NUMOBS_MORE"], 0, None)
    # AR updating numobs
    h[1].data["NUMOBS"][ii0] += counts[ii1]
    # AR updating NUMOBS_DONE
    h[1].data["NUMOBS_DONE"][ii0, passid] = counts[ii1]
    # AR updating Lya
    # AR QSO observed in passid which are not Lya
    if args.program == "dark":
        keep = (
            ((h[1].data[dtkey] & desi_mask["QSO"]) > 0)
            & (h[1].data["NUMOBS_DONE"][:, passid] > 0)
            & (~h[1].data["ISLYA"])
        )
        h[1].data["NUMOBS_MORE"][keep] = 0
    # AR emulate mtl update?
    # AR if yes, updates: Z, ZWARN, ZTILEID, PRIORITY, TARGET_STATE
    if args.mtl_update == "y":
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\tmtl_update start".format(
                time() - start, passid
            )
        )
        # AR fake ztargets table, cf. make_mtl()
        # AR in make_mtl(): targets => h[1].data here
        n1 = len(ii1)
        ztargets = Table()
        ztargets["TARGETID"] = tids[ii1]
        ztargets["NUMOBS"] = counts[ii1]
        # AR 0 < Z < 2
        ztargets["Z"] = np.random.uniform(low=0, high=2.0, size=n1)
        # AR 2.1 < Z < 5 for Lya
        if args.program == "dark":
            ztargets["Z"][h[1].data["ISLYA"][ii0]] = np.random.uniform(
                low=2.1, high=5, size=h[1].data["ISLYA"][ii0].sum()
            )
        # AR Z_QN, IS_QSO_QN: used as an alternative diagnosis for Lya
        # AR    we rely only on Z here
        # AR    we use the default values created by desitarget.mtl.make_mtl()
        # AR    i.e. Z_QN = IS_QSO_QN = -1
        # AR    that way, the following condition is always False:
        # AR        ((zcat['Z_QN'] >= zcut) & (zcat["IS_QSO_QN"] == 1))
        # AR    https://github.com/desihub/desitarget/blob/bb5d5c99f187631c3ac9d4a1eb60716a6076d164/py/desitarget/targets.py#L745-L752
        ztargets["Z_QN"] = h[1].data["Z_QN"][ii0]
        ztargets["IS_QSO_QN"] = h[1].data["IS_QSO_QN"][ii0]
        ztargets["ZWARN"] = np.zeros(n1, dtype=np.int32)
        ztargets["ZTILEID"] = 1 * np.ones(n1, dtype=np.int32)
        ztargets["NUMOBS_MORE"] = h[1].data["NUMOBS_MORE"][ii0]  # AR added
        zmatcher = ii0.copy()
        # ADM extract just the targets that match the input zcat.
        targets_zmatcher = h[1].data[zmatcher]
        # ADM assign priorities. Only things in the zcat can have changed
        # ADM priorities. Anything else is assigned PRIORITY_INIT, below.
        priority, target_state = calc_priority(
            targets_zmatcher, ztargets, args.program.upper(), state=True
        )
        # ADM now populate the new mtl columns with the updated information.
        h[1].data["PRIORITY"][zmatcher] = priority
        h[1].data["TARGET_STATE"][zmatcher] = target_state
        for col in ["Z", "ZWARN", "ZTILEID"]:
            h[1].data[col][zmatcher] = ztargets[col]
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\tmtl_update done".format(
                time() - start, passid
            )
        )
    # AR change priority of observed Lya?
    if (args.program == "dark") & (args.priority_lya is not None):
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\tpriority_lya start".format(
                time() - start, passid
            )
        )
        keep = (h[1].data["ISLYA"]) & (h[1].data["NUMOBS_DONE"][:, passid] > 0)
        h[1].data["PRIORITY"][keep] = args.priority_lya
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\tpriority_lya done".format(
                time() - start, passid
            )
        )
    # AR nfiber_avail, ntile_avail
    for sample, key in zip(["potential", "targets"], ["NFIBER_AVAIL", "NTILE_AVAIL"]):
        log.info(
            "{:.1f}s\tupdate_after_farun\tpassid={}\tbuilding {}".format(
                time() - start, passid, key
            )
        )
        tids = np.array(myd[sample]["TARGETID"])
        tids, counts = np.unique(tids, return_counts=True)
        ii0, ii1 = match(h[1].data["TARGETID"], tids)
        h[1].data[key][ii0, passid] = counts[ii1]
    # writing output
    log.info(
        "{:.1f}s\tupdate_after_farun\tpassid={}\tstart writing {}".format(
            time() - start, passid, output_targ
        )
    )
    h.writeto(output_targ, overwrite=True)
    log.info(
        "{:.1f}s\tupdate_after_farun\tpassid={}\tdone writing {}".format(
            time() - start, passid, output_targ
        )
    )
    return True


# AR selects object inside a "box" with a given margin in degrees
# AR cuts in Dec.: decmin + margin < dec < decmax - margin
# AR cuts in R.A.: accounts for the cos(Dec.) term with a 1-deg grid in Dec.
def sel_margin(ras, decs, radec, margin):
    ramin, ramax, decmin, decmax = [float(x) for x in radec.split(",")]
    keep = (decs > decmin + margin) & (decs < decmax - margin)
    ra_margins = margin / np.cos(np.radians(decs))
    if ramax < ramin:
        reject_ramin = (ras > ramin) & (ras < ramin + ra_margins)
        reject_ramax = (ras < ramax) & (ras > ramax - ra_margins)
    else:
        reject_ramin = ras < ramin + ra_margins
        reject_ramax = ras > ramax - ra_margins
    keep[(reject_ramin) | (reject_ramax)] = False
    return keep


# AR get the tile area and the safe "box" area
# AR picking one pixweight file
# AR we just want the fracarea here
def get_area(radec, tiles, margin):
    if args.dr == "dr8":
        fn = "{}/targets/catalogs/dr8/0.31.1/pixweight/pixweight-dr8-0.31.1.fits".format(
            os.getenv("DESI_ROOT")
        )
    if args.dr == "dr9":
        fn = "{}/target/catalogs/dr9/0.47.0/pixweight/main/resolve/dark/pixweight-dark.fits".format(
            os.getenv("DESI_ROOT")
        )
    h = fits.open(fn)
    nside, nest = h[1].header["HPXNSIDE"], h[1].header["HPXNEST"]
    theta, phi = hp.pix2ang(nside, np.arange(hp.nside2npix(nside)), nest=nest)
    ras, decs = 180.0 / np.pi * phi, 90.0 - 180.0 / np.pi * theta
    # AR cutting on tiles
    keep = is_point_in_desi(tiles, ras, decs)
    area_tile = np.round(
        h[1].data["FRACAREA"][keep].sum() * hp.nside2pixarea(nside, degrees=True), 0
    )
    # AR further cutting on margins
    keep &= sel_margin(ras, decs, radec, margin)
    area_safe = np.round(
        h[1].data["FRACAREA"][keep].sum() * hp.nside2pixarea(nside, degrees=True), 0
    )
    return area_tile, area_safe


# AR select tracers
def sel_tracer(d, tracer):
    if tracer == "ALL":
        return np.ones(len(d), dtype=bool)
    elif tracer == "LYA":
        return ((d[dtkey] & desi_mask["QSO"]) > 0) & (d["ISLYA"])
    elif tracer in ["BGS_BRIGHT", "BGS_FAINT"]:
        return (d[btkey] & bgs_mask[tracer]) > 0
    else:
        return (d[dtkey] & desi_mask[tracer]) > 0


# AR fastats-targ
# AR ! should be run on a region excluding the edges !
def fastats_targ(tracers, targ_fn, area):
    d = fits.open(targ_fn)[1].data
    # AR number of assigned fibers per target
    numobs_tot = d["NUMOBS_DONE"].sum(axis=1)
    # AR
    f = open(get_fn(args.outdir, "fastats-targ"), "w")
    f.write("# TRACER PRIORITY_INIT TARGET_DENS DONE_FRAC DONE_DENS MEAN_NFIBER\n")
    for tracer in tracers:
        ist = sel_tracer(d, tracer)
        # AR done?
        if tracer == "LYA":
            isdone = (ist) & (numobs_tot >= 4)
        else:
            isdone = (ist) & (numobs_tot >= 1)
        prios = ["ALL"]
        if tracer != "ALL":
            prios += np.unique(d["PRIORITY_INIT"][ist]).tolist()
        for prio in prios:
            if prio == "ALL":
                istp = ist.copy()
            else:
                istp = (ist) & (d["PRIORITY_INIT"] == prio)
            # AR done?
            if tracer == "LYA":
                istpd = (istp) & (numobs_tot >= 4)
            else:
                istpd = (istp) & (numobs_tot >= 1)
            f.write(
                "{}\t{}\t{:.0f}\t{:.2f}\t{:.0f}\t{:.1f}\n".format(
                    tracer,
                    prio,
                    istp.sum() / area,
                    istpd.sum() / istp.sum(),
                    istpd.sum() / area,
                    numobs_tot[istp].mean(),
                )
            )
    f.close()
    return True


# AR fastats-sky
def fastats_sky(passids, area):
    # AR
    f = open(get_fn(args.outdir, "fastats-sky"), "w")
    f.write("# PASS DONE_DENS EXTRA_DENS\n")
    ntot, ntot_extra = 0, 0
    for i in range(len(passids)):
        fn = os.path.join(
            args.outdir,
            "faruns",
            "farun-pass{}".format(passids[i]),
            "fba-sky-pass{}.fits".format(passids[i]),
        )
        d = fits.open(fn)[1].data
        # AR before cutting on "safe" box, assigning "extra" status to nfiber - (ntile x 10 x sky_per_petal fibers)
        ntile = len(fits.open(get_fn(args.outdir, "tiles", passid=passids[i]))[1].data)
        nextra = len(d) - ntile * 10 * int(args.sky_per_petal)
        ii = np.random.choice(len(d), size=nextra, replace=False)
        is_extra = np.zeros(len(d), dtype=bool)
        is_extra[ii] = True
        # AR cutting out a safe "box" for analysis
        keep = sel_margin(
            d["TARGET_RA"], d["TARGET_DEC"], args.radec, args.radec_margin
        )
        f.write(
            "{}\t{:.0f}\t{:.0f}\n".format(
                passids[i], keep.sum() / area, ((keep) & (is_extra)).sum() / area
            )
        )
        ntot += keep.sum()
        ntot_extra += ((keep) & (is_extra)).sum()
    f.write("ALL\t{:.0f}\t{:.0f}".format(ntot / area, ntot_extra / area))
    f.close()
    return True


# AR find all pairs with search_radius (arcsec)
# AR copied from https://github.com/rongpu/desi-examples/blob/master/bright_star_contamination/match_coord.py
def search_around(ra1, dec1, ra2, dec2, search_radius=1.0, verbose=True):
    # protect the global variables from being changed by np.sort
    ra1, dec1, ra2, dec2 = list(map(np.copy, [ra1, dec1, ra2, dec2]))
    # Matching catalogs
    sky1 = SkyCoord(ra1 * units.degree, dec1 * units.degree, frame="icrs")
    sky2 = SkyCoord(ra2 * units.degree, dec2 * units.degree, frame="icrs")
    idx1, idx2, d2d, d3d = sky2.search_around_sky(
        sky1, seplimit=search_radius * units.arcsec
    )
    if verbose:
        log.info(("%d nearby objects" % len(idx1)))
    # convert distances to numpy array in arcsec
    d2d = np.array(d2d.to(units.arcsec))
    d_ra = (ra2[idx2] - ra1[idx1]) * 3600.0  # in arcsec
    d_dec = (dec2[idx2] - dec1[idx1]) * 3600.0  # in arcsec
    ##### Convert d_ra to actual arcsecs #####
    mask = d_ra > 180 * 3600
    d_ra[mask] = d_ra[mask] - 360.0 * 3600
    mask = d_ra < -180 * 3600
    d_ra[mask] = d_ra[mask] + 360.0 * 3600
    d_ra = d_ra * np.cos(dec1[idx1] / 180 * np.pi)
    ##########################################
    return idx1, idx2, d2d, d_ra, d_dec


# AR pair count diagnosis
# AR ! should be run on a region excluding the edges !
# AR based on Ashley https://github.com/desihub/LSS/blob/master/Sandbox/testassignments.ipynb
def fastats_pairs(tracers, targ_fn, d2dmax_degree):
    d = fits.open(targ_fn)[1].data
    ras, decs = d["RA"], d["DEC"]
    # AR number of assigned fibers per target
    numobs_tot = d["NUMOBS_DONE"].sum(axis=1)
    # AR count pairs
    f = open(get_fn(args.outdir, "fastats-pairs"), "w")
    f.write("# TRACER1 TRACER2 ASSGN2TGT RAND2TGT RATIO\n")
    for i1 in range(len(tracers) - 1):
        tracer1 = tracers[i1]
        ist1 = sel_tracer(d, tracer1)
        ist1assgn = (ist1) & (numobs_tot >= 1)
        for i2 in range(i1 + 1, len(tracers)):
            tracer2 = tracers[i2]
            ist2 = sel_tracer(d, tracer2)
            # AR excluding tracer1
            ist2 &= ~ist1
            ist2assgn = (ist2) & (numobs_tot >= 1)
            # AR TGT pairs
            _, _, d2d, _, _ = search_around(
                ras[ist1],
                decs[ist1],
                ras[ist2],
                decs[ist2],
                search_radius=d2dmax_degree * 3600,
                verbose=False,
            )
            np_tgt = len(d2d)
            # AR ASSGN pairs
            _, _, d2d, _, _ = search_around(
                ras[ist1assgn],
                decs[ist1assgn],
                ras[ist2assgn],
                decs[ist2assgn],
                search_radius=d2dmax_degree * 3600,
                verbose=False,
            )
            np_assgn = len(d2d)
            # AR fraction of pairs with both assigned
            frac_assgn = np_assgn / np_tgt
            # AR fraction of pairs if random
            frac_rand = (ist1assgn.sum() / ist1.sum()) * (ist2assgn.sum() / ist2.sum())
            f.write(
                "{}\t{}\t{:.2f}\t{:.2f}\t{:.2f}\n".format(
                    tracer1, tracer2, frac_assgn, frac_rand, frac_assgn / frac_rand,
                )
            )
    f.close()
    return True


def main():

    # AR print start time
    log.info(
        "{:.1f}s\tsettings\tstarting at utc_time={}".format(
            time() - start, utc_time_now_str
        )
    )

    # AR printing settings
    tmpstr = " , ".join(
        [kwargs[0] + "=" + str(kwargs[1]) for kwargs in args._get_kwargs()]
    )
    log.info("{:.1f}s\tsettings\targs: {}".format(time() - start, tmpstr))

    # AR machine
    log.info(
        "{:.1f}s\tsettings\tHOSTNAME={}".format(time() - start, os.getenv("HOSTNAME"))
    )
    # AR fiberassign, desitarget, desimodel code version, path
    for module, name in zip(
        [fiberassign, desitarget, desimodel], ["fiberassign", "desitarget", "desimodel"]
    ):
        log.info(
            "{:.1f}s\tsettings\trunning with {} code version: {}".format(
                time() - start, name, module.__version__
            )
        )
        log.info(
            "{:.1f}s\tsettings\trunning with {} code path: {}".format(
                time() - start, name, module.__path__
            )
        )

    # AR create the tiles files
    if "tiles" in args.steps.split(","):
        # AR then create tiles file
        _ = create_tiles(args.tilesfn, args.program, args.radec, args.outdir)

    # AR safe "box" area
    tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
    area_tile, area_safe = get_area(args.radec, tiles, args.radec_margin)
    log.info(
        "{:.1f}s\tdotile\tarea_tile={} deg2, area_safe={} deg2".format(
            time() - start, area_tile, area_safe
        )
    )

    # AR create the sky file
    if ("sky" in args.steps.split(",")) & (args.numproc == 1):
        _ = create_sky(get_fn(args.outdir, "tiles"), get_fn(args.outdir, "sky"))

    # AR create the targets file
    if "targ" in args.steps.split(","):
        log.info("{:.1f}s\tdotarg\tstart".format(time() - start))
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        # AR use randoms instead of targets?
        if args.randoms == "y":
            d, rand_dens = wrapper_read_randoms()
        else:
            d = wrapper_read_targets()
        log.info("{:.1f}s\tdotarg\tdone reading targets".format(time() - start))
        # AR mtl
        myd = Table(d)
        # AR assigns Lya
        if args.program == "dark":
            myd["ISLYA"] = set_lya(d, args.lyafrac)
            log.info("{:.1f}s\tdotarg\tdone setting islya".format(time() - start))
        # AR to store fa stats
        for key in ["NFIBER_AVAIL", "NTILE_AVAIL", "NUMOBS_DONE"]:
            myd[key] = np.zeros((len(d), args.npass), dtype=int)
        log.info("{:.1f}s\tdotarg\tdone creating empty cols".format(time() - start))
        # AR flagging "safe" radec
        myd["ISRADEC_SAFE"] = sel_margin(
            d["RA"], d["DEC"], args.radec, args.radec_margin
        )
        log.info("{:.1f}s\tdotarg\tdone isradec_safe".format(time() - start))
        # AR mtl
        mtl = make_mtl(myd.as_array(), args.program.upper())
        log.info("{:.1f}s\tdotarg\tdone make_mtl".format(time() - start))
        # AR tweak priority?
        if args.priority_mask is not None:
            mtl = tweak_priority(
                mtl, args.priority_mask, args.priority_frac, args.priority_new
            )
        log.info(
            "{:.1f}s\tdotarg\tstart writing {}".format(
                time() - start, get_fn(args.outdir, "targ")
            )
        )
        mtl.write(get_fn(args.outdir, "targ"), overwrite=True)
        # AR propagating some settings into the PRIMARY header
        fd = fitsio.FITS(get_fn(args.outdir, "targ"), "rw")
        fd["MTL"].write_key("DTVER", args.dtver)
        fd["MTL"].write_key("SURVEY", args.survey)
        fd["MTL"].write_key("PROGRAM", args.program)
        fd["MTL"].write_key("RADEC", args.radec)
        fd["MTL"].write_key("MARGIN", args.radec_margin)
        fd["MTL"].write_key("AREATILE", area_tile)
        fd["MTL"].write_key("AREASAFE", area_safe)
        fd["MTL"].write_key("PRIOMASK", args.priority_mask)
        fd["MTL"].write_key("PRIOFRAC", args.priority_frac)
        fd["MTL"].write_key("PRIONEW", args.priority_new)
        fd["MTL"].write_key("NUMINIT", args.numobs_init_notqso)
        fd["MTL"].write_key("NUMINITQ", args.numobs_init_qso)
        fd["MTL"].write_key("TILESFN", args.tilesfn)
        fd["MTL"].write_key("RUNDATE", args.rundate)
        fd["MTL"].write_key("NSKYPET", args.sky_per_petal)
        fd["MTL"].write_key("NSTDPET", args.standards_per_petal)
        fd["MTL"].write_key("NSKYPSL", args.sky_per_slitblock)
        fd["MTL"].write_key("MARGPOS", args.margin_pos)
        fd["MTL"].write_key("MARGGFA", args.margin_gfa)
        fd["MTL"].write_key("MARGPET", args.margin_petal)
        if args.randoms == "y":
            fd["MTL"].write_key("RANDDENS", rand_dens)
        fd.close()
        log.info(
            "{:.1f}s\tdotarg\tdone writing {}".format(
                time() - start, get_fn(args.outdir, "targ")
            )
        )

    # AR run the fiber assignment + update the target file
    if "fa" in args.steps.split(","):
        # AR listing passids
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        passids = np.unique(tiles["PASS"])
        # AR looping on passids
        for ip in range(len(passids)):
            log.info(
                "{:.1f}s\tdofa\tstart passid={}".format(time() - start, passids[ip])
            )
            passid = passids[ip]
            # AR file/directory names
            if ip == 0:
                input_targ = get_fn(args.outdir, "targ")
                # AR targ_ra, targ_dec for as global variable if args.numproc > 1
                # AR same for all passids
                if args.numproc > 1:
                    global targ_ra, targ_dec
                    d = fitsio.read(input_targ, columns=["RA", "DEC"])
                    targ_ra, targ_dec = d["RA"], d["DEC"]
            else:
                input_targ = get_fn(args.outdir, "targ", passids[ip - 1])
            fadir = os.path.join(args.outdir, "faruns", "farun-pass{}".format(passid))
            output_targ = get_fn(args.outdir, "targ", passid)
            # AR clean fadir folder
            fns = glob(os.path.join(fadir, "fba-*.fits*"))
            if len(fns) > 0:
                for fn in fns:
                    os.remove(fn)
            # AR run fiber assignment
            if args.numproc == 1:
                opts = [
                    "--rundate",
                    args.rundate,
                    "--overwrite",
                    "--write_all_targets",
                    "--footprint",
                    get_fn(args.outdir, "tiles", passid=passid),
                    "--dir",
                    fadir,
                    "--sky",
                    get_fn(args.outdir, "sky"),
                    "--targets",
                    input_targ,
                    "--sky_per_petal",
                    args.sky_per_petal,
                    "--standards_per_petal",
                    args.standards_per_petal,
                ]
                log.info(
                    "{:.1f}s\tdofa\trun_assign_full with 1 processor".format(
                        time() - start
                    )
                )
                ag = parse_assign(opts)
                run_assign_full(ag)
            else:
                # AR tileids for that passid
                tileids = tiles["TILEID"][tiles["PASS"] == passid]
                # AR tiles file for that passid
                foot_pass = get_fn(args.outdir, "tiles", passid=passid)
                # AR preparing files per tileid
                intargfn_fadir_footfn_skyfn_targfn = []
                for tileid in tileids:
                    # AR tileid filenames
                    footfn = foot_pass.replace(
                        ".fits", "-{:06d}.fits".format(int(tileid))
                    )
                    skyfn = footfn.replace("tiles-", "sky-")
                    targfn = footfn.replace("tiles-", "targ-")
                    d = fitsio.read(foot_pass)
                    d = d[d["TILEID"] == tileid]
                    fitsio.write(footfn, d, clobber=True)
                    # AR
                    intargfn_fadir_footfn_skyfn_targfn += [
                        ",".join([input_targ, fadir, footfn, skyfn, targfn])
                    ]
                pool = sharedmem.MapReduce(np=args.numproc)
                with pool:
                    _ = pool.map(
                        _do_run_assign_full, intargfn_fadir_footfn_skyfn_targfn
                    )
            log.info(
                "{:.1f}s\tdofa\tfba done passid={}".format(time() - start, passids[ip])
            )
            # AR update the catalogs after having run fa + stats
            _ = update_after_farun(input_targ, fadir, passid, output_targ)
        # AR after last run, we provide a catalog cut on the safe region
        d = fitsio.read(get_fn(args.outdir, "targ", passid))
        d = d[d["ISRADEC_SAFE"]]
        fitsio.write(
            get_fn(args.outdir, "targ", passid).replace(".fits", "-radec_safe.fits"),
            d,
            clobber=True,
        )

    # AR analyze the runs
    if "stats" in args.steps.split(","):
        # AR passids
        tiles = fits.open(get_fn(args.outdir, "tiles"))[1].data
        passids = np.unique(tiles["PASS"])

        # AR fastats-targ:
        # AR using the run for the last passid, cut on the "safe" region
        if args.randoms == "y":
            tracers = ["ELG"]
        else:
            if args.program == "dark":
                tracers = ["ALL", "LYA", "QSO", "LRG", "ELG"]
            else:
                tracers = ["ALL", "BGS_BRIGHT", "BGS_FAINT", "MWS_ANY"]
        targ_fn = get_fn(args.outdir, "targ", passid=args.npass - 1).replace(
            ".fits", "-radec_safe.fits"
        )
        _ = fastats_targ(tracers, targ_fn, area_safe)

        # AR basic pair counting
        # AR cf. Ashley https://github.com/desihub/LSS/blob/master/Sandbox/testassignments.ipynb
        if args.randoms == "n":
            if args.program == "dark":
                tracers = ["QSO", "LRG", "ELG"]
            else:
                tracers = ["BGS_BRIGHT", "BGS_FAINT"]
            d2dmax_degree = 0.01
            _ = fastats_pairs(tracers, targ_fn, d2dmax_degree)

        # AR fastats-sky:
        # AR using the whole region to get the numbers right
        _ = fastats_sky(passids, area_tile)

    # AR print end time
    log.info(
        "{:.1f}s\tsettings\tfinished at utc_time={}".format(
            time() - start, datetime.now(tz=timezone.utc).isoformat(timespec="seconds")
        )
    )


if __name__ == "__main__":

    # AR allowed steps in desi_fa_smallrun
    steps_all = ["tiles", "sky", "targ", "fa", "stats"]

    # AR reading arguments
    parser = ArgumentParser()
    parser.add_argument(
        "--outdir",
        help="root directory; all other paths are relative to that directory",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--program",
        help="dark or bright (default=dark)",
        type=str,
        default="dark",
        choices=["dark", "bright"],
    )
    parser.add_argument(
        "--randoms",
        help="use 2500/deg2 randoms instead of targets (default=n)",
        type=str,
        default="n",
        choices=["y", "n"],
    )
    parser.add_argument(
        "--radec",
        help="ramin,ramax,decmin,decmax boundaries for tile centres (default=160,200,45,60)",
        type=str,
        default="160,200,45,60",
    )
    parser.add_argument(
        "--rundate",
        help="yyyy-mm-ddThh:mm:ss+00:00 rundate for focalplane with UTC timezone formatting (default=current UTC time)",
        type=str,
        default=None,
        required=False,
    )
    parser.add_argument(
        "--dr",
        help="legacypipe dr (default=dr9)",
        type=str,
        default="dr9",
        choices=["dr8", "dr9"],
    )
    parser.add_argument(
        "--survey",
        help="main, sv1, sv2, sv3 (default=None)",
        type=str,
        default=None,
        choices=["sv1", "sv2", "sv3", "main"],
        required=True,
    )
    parser.add_argument(
        "--dtver",
        help="desitarget version (default=0.57.0)",
        type=str,
        default="0.57.0",
    )
    parser.add_argument(
        "--lyafrac",
        help="fraction of QSO targets which are Lya (default=0.2)",
        type=float,
        default=0.2,
    )
    parser.add_argument(
        "--tilesfn",
        help="tiles file full path (default: $DESI_SURVEYOPS/ops/tiles-main.ecsv)",
        type=str,
        default="{}/ops/tiles-main.ecsv".format(
            os.getenv("DESI_SURVEYOPS")
        ),
    )
    parser.add_argument(
        "--npass",
        help="number of tiling passes for the run (default: dark=7, bright=backup=4)",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--standards_per_petal",
        help="required number of standards per petal (default=10)",
        type=str,
        default="10",
    )
    parser.add_argument(
        "--sky_per_petal",
        help="required number of sky targets per petal (default=40)",
        type=str,
        default="40",
    )
    parser.add_argument(
        "--sky_per_slitblock",
        help="Required number of sky targets per fiber slitblock (default=1)",
        type=int,
        default=1,
        required=False,
    )
    parser.add_argument("--margin-pos", "--margin_pos", type=float, required=False, default=0.05,
                        help="Add margin (in mm) around positioner keep-out polygons (default: 0.05)")
    parser.add_argument("--margin-petal", "--margin_petal", type=float, required=False, default=0.4,
                        help="Add margin (in mm) around petal-boundary keep-out polygons (default: 0.4)")
    parser.add_argument("--margin-gfa", "--margin_gfa", type=float, required=False, default=0.4,
                        help="Add margin (in mm) around GFA keep-out polygons (default: 0.4)")
    parser.add_argument(
        "--priority_mask",
        help="comma-separated list of the desi_mask names to promote the priority of (e.g. ELG_HIP,LRG)",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--priority_frac",
        help="comma-separated list of the fraction of --priority_mask targets to promote (e.g. 0.25,0.15)",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--priority_new",
        help="comma-separated list of the priority values to promote the --priority_mask to (e.g. 3400,3400)",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--priority_lya",
        help="once observed, priority to be set for Lya (default=None, i.e. keep the same priority)",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--numobs_init_notqso",
        help="force NUMOBS_INIT for not-QSO object (default=None)",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--numobs_init_qso",
        help="force NUMOBS_INIT for QSO object (default=None)",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--mtl_update",
        help="emulate mtl update of Z, ZWARN, ZTILEID, PRIORITY, TARGET_STATE after each pass? (default=y)",
        type=str,
        default="y",
        choices=["y", "n"],
    )
    parser.add_argument(
        "--radec_margin",
        help="margin in degrees to safely extract an inner box for analysis with non boundary effects; box will be cut by args.radec_margin in Dec. and args.radec_margin/cos(Dec.) in R.A. (default=2)",
        type=float,
        default=2,
    )
    parser.add_argument(
        "--nolog", help="do not print log file (default=n)", type=str, default="n",
    )
    parser.add_argument(
        "--numproc",
        help="number of concurrent processes to use (default=1)",
        type=int,
        default=1,
    )
    parser.add_argument(
        "--desi_target_env",
        help="$DESI_TARGET environment variable, to look up targets (default=existing one)",
        type=str,
        default=os.getenv("DESI_TARGET"),
    )
    parser.add_argument(
        "--steps",
        help="comma-separated list of steps to accomplish, amongst {} (defaults={})".format(steps_all, ",".join(steps_all)),
        type=str,
        default=",".join(steps_all),
    )
    #
    args = parser.parse_args()
    log = Logger.get()
    start = time()

    # AR npass
    if args.npass is None:
        args.npass = 7 * (args.program == "dark") + 4 * (args.program != "dark")

    # AR steps
    wrong_steps = [step for step in args.steps.split(",") if step not in steps_all]
    if len(wrong_steps) > 0:
        log.error("args.steps have the following not authorized steps : {}; exiting".format(
            wrong_steps
            )
        )
        sys.exit(1)

    # AR utc_time_now, rundate
    utc_time_now = datetime.now(tz=timezone.utc)
    utc_time_now_str = utc_time_now.isoformat(timespec="seconds")
    if args.rundate is None:
        args.rundate = utc_time_now_str
    # AR rundate correctly formatted?
    if not assert_isoformat_utc(args.rundate):
        log.error(
            "args.rundate={} is not yyyy-mm-ddThh:mm:ss+00:00; exiting".format(
                args.rundate
            )
        )
        sys.exit()

    # AR safe
    if args.outdir[-1] != "/":
        args.outdir += "/"
    if (args.lyafrac < 0) | (args.lyafrac > 1):
        log.error(
            "args.lyafrac = {} => should be within 0 and 1; exiting".format(ags.lyafrac)
        )
        sys.exit()
    pm, pf, pn = args.priority_mask, args.priority_frac, args.priority_new
    if (pm is not None) | (pf is not None) | (pn is not None):
        if (pm is None) | (pf is None) | (pn is None):
            log.error(
                "args.priority_mask, args.priority_frac, args.priority_new should all be or not be None; exiting"
            )
            sys.exit()
        npm, npf, npn = len(pm.split(",")), len(pf.split(",")), len(pn.split(","))
        if (npm != npf) | (npm != npn) | (npf != npn):
            log.error(
                "inconsistent args.priority_mask, args.priority_frac, args.priority_new; exiting"
            )
            sys.exit()

    for kwargs in args._get_kwargs():
        print(kwargs)

    # AR outdir
    if not os.path.isdir(args.outdir):
        os.mkdir(args.outdir)

    # AR subdirs
    for subdir in ["inputs", "faruns", "outputs"]:
        if not os.path.isdir(os.path.join(args.outdir, subdir)):
            os.mkdir(os.path.join(args.outdir, subdir))

    # AR cleaning
    fns = []
    if "tiles" in args.steps.split(","):
        for passid in [None] + np.arange(11, dtype=int).tolist():
            fns += [get_fn(args.outdir, "tiles", passid=passid)]
    if "sky" in args.steps.split(","):
        fns += [get_fn(args.outdir, "sky")]
    if "targ" in args.steps.split(","):
        fns += [get_fn(args.outdir, "targ")]
    if "fa" in args.steps.split(","):
        fns += glob(os.path.join(args.outdir, "faruns", "farun-pass*", "fba*fits"))
        for t in ["tiles", "sky", "targ"]:
            fns += glob(os.path.join(args.outdir, "faruns", "farun-pass*", "{}-pass*-??????.fits".format(t)))
        fns += [
            get_fn(args.outdir, "targ", passid=passid)
            for passid in np.arange(args.npass, dtype=int)
        ]
        fns += [
            get_fn(args.outdir, "targ", passid=args.npass - 1).replace(
                ".fits", "-radec_safe.fits"
            )
        ]
    if "stats" in args.steps.split(","):
        fns += [
            get_fn(args.outdir, "fastats-targ"),
            get_fn(args.outdir, "fastats-sky"),
            get_fn(args.outdir, "fastats-pairs"),
        ]
    #
    for fn in fns:
        if os.path.isfile(fn):
            os.remove(fn)

    # AR saving settings
    fn = open(get_fn(args.outdir, "settings", steps=args.steps), "w")
    for kwargs in args._get_kwargs():
        fn.write("{} = {}\n".format(kwargs[0], kwargs[1]))
    fn.write("\n")
    fn.write(
        "python {} {}\n".format(
            sys.argv[0],
            " ".join(
                [
                    "--" + kwargs[0] + " " + str(kwargs[1])
                    for kwargs in args._get_kwargs()
                    if kwargs[1] is not None
                ]
            ),
        )
    )
    fn.write("\n")
    fn.close()

    # AR log file
    if args.nolog == "n":
        logfn = get_fn(args.outdir, "log", steps=args.steps)
    else:
        logfn = None

    # AR reproducible random seed
    np.random.seed(12345)

    # AR mask + key used to select targets
    if args.survey == "main":
        from desitarget.targetmask import desi_mask, bgs_mask

        dtkey, btkey = "DESI_TARGET", "BGS_TARGET"
    if args.survey == "sv1":
        from desitarget.sv1.sv1_targetmask import desi_mask, bgs_mask

        dtkey, btkey = "SV1_DESI_TARGET", "SV1_BGS_TARGET"
    if args.survey == "sv2":
        from desitarget.sv2.sv2_targetmask import desi_mask, bgs_mask

        dtkey, btkey = "SV2_DESI_TARGET", "SV2_BGS_TARGET"
    if args.survey == "sv3":
        from desitarget.sv3.sv3_targetmask import desi_mask, bgs_mask

        dtkey, btkey = "SV3_DESI_TARGET", "SV3_BGS_TARGET"

    # AR: log filename
    if args.nolog == "n":
        if os.path.isfile(logfn):
            os.remove(logfn)
        with stdouterr_redirected(to=logfn):
            main()
    else:
        main()
