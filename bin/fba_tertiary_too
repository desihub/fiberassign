#!/usr/bin/env python

import sys
import os
import numpy as np
from astropy.table import Table
from time import time
from datetime import datetime, timezone
from astropy.time import Time
from desitarget.targetmask import desi_mask
from desitarget.targetmask import obsconditions
from desitarget.targets import encode_targetid, decode_targetid
from desitarget.targetmask import desi_mask, scnd_mask
from desitarget.mtl import get_utc_date
from desimodel.footprint import is_point_in_desi
from fiberassign.utils import assert_isoformat_utc
from fiberassign.utils import Logger
from argparse import ArgumentParser

log = Logger.get()

# AR release is hard-coded to 8888 for tertiary programs
release = 8888

# AR default values
default = {
    "TIME_MJD_BEGIN": "2020-01-01T00:00:00+00:00",
    "TIME_MJD_END": "2120-01-01T00:00:00+00:00",
    "TOO_PRIO": "HI", # for TOO_PRIO and SCND_TARGET
}

# AR required columns from {args.targdir}/tertiary-targets-{args.prognum}.fits
req_keys = [
    "RA",
    "DEC",
    "PMRA",
    "PMDEC",
    "REF_EPOCH",
    "NUMOBS_INIT",
    "PRIORITY_INIT",
    "PRIORITY_DONE",
    "CHECKER",
]

# AR reproducibility for SUBPRIORITY
np_rand_seed = 1234
np.random.seed(np_rand_seed)


def get_parse():
    parser = ArgumentParser()
    parser.add_argument(
        "--tileid",
        help="tileid (default=None)",
        type=int,
        required=True,
        default=None,
    )
    parser.add_argument(
        "--tilera",
        help="tile centre ra (default=None)",
        type=float,
        required=True,
        default=None,
    )
    parser.add_argument(
        "--tiledec",
        help="tile centre dec (default=None)",
        type=float,
        required=True,
        default=None,
    )
    parser.add_argument(
        "--targdir",
        help="target folder (default=$DESI_SURVEYOPS/tertiary/args.prognum))",
        type=str,
        default=None,
    )
    parser.add_argument(
        "--fadir",
        help="fiberassign folder (default=None)",
        type=str,
        required=True,
        default=None,
    )
    parser.add_argument(
        "--prognum",
        help="prognum (used as BRICKID for TARGETID), <1e5 (default=None)",
        type=int,
        required=True,
        default=None,
    )
    parser.add_argument(
        "--utc_time_mjd_begin",
        help="yyyy-mm-ddThh:mm:ss+00:00 time for MJD_BEGIN UTC timezone formatting (default={})".format(
            default["TIME_MJD_BEGIN"]
        ),
        type=str,
        default=default["TIME_MJD_BEGIN"],
    )
    parser.add_argument(
        "--utc_time_mjd_end",
        help="yyyy-mm-ddThh:mm:ss+00:00 time for MJD_END UTC timezone formatting (default={})".format(
            default["TIME_MJD_END"]
        ),
        type=str,
        default=default["TIME_MJD_END"],
    )
    parser.add_argument(
        "--obsconditions",
        help="observing conditions (default=None)",
        choices=["BRIGHT", "DARK"],
        required=True,
        default=None,
    )
    parser.add_argument(
        "--desi_mask_name",
        help="name for DESI_TARGET (default=SCND_ANY)",
        type=str,
        default="SCND_ANY",
    )
    parser.add_argument(
        "--scnd_mask_name",
        help="name for SCND_TARGET (default={{args.obsconditions}}_TOO_{}P)".format(default["TOO_PRIO"]),
        type=str,
        default=None,
    )
    parser.add_argument(
        "--previous_tileids",
        help="comma-separated list of already designed TILEIDs to consider to set NUMOBS and NUMOBS_MORE (default=None)",
        type=str,
        default=None,
    )
    args = parser.parse_args()
    # AR targdir
    if args.targdir is None:
        args.targdir = os.path.join(os.getenv("DESI_SURVEYOPS"), "ops", "tertiary", "{:04d}".format(args.prognum))
    # AR scnd_mask_name
    if args.scnd_mask_name is None:
        args.scnd_mask_name = "{}_TOO_{}P".format(args.obsconditions, default["TOO_PRIO"])
    for kwargs in args._get_kwargs():
        print(kwargs)
    return args


def get_toofn(targdir, prognum, tileid):
    return os.path.join(
        targdir, "ToO-{:04d}-{:06d}.ecsv".format(prognum, tileid)
    )


def get_mjd(utc_time_mjd):
    assert_isoformat_utc(utc_time_mjd)
    return Time(datetime.strptime(utc_time_mjd, "%Y-%m-%dT%H:%M:%S%z")).mjd


def main():

    args = get_parse()

    # AR output file
    toofn = get_toofn(args.targdir, args.prognum, args.tileid)
    if os.path.isfile(toofn):
        msg = "{} already exists! exiting"
        log.error(msg)
        raise IOError(msg)
    else:
        log.info("toofn = {}".format(toofn))

    # AR mjd_begin, mjd_end
    mjd_begin = get_mjd(args.utc_time_mjd_begin)
    mjd_end = get_mjd(args.utc_time_mjd_end)
    log.info("set MJD_BEGIN={}, MJD_END={}".format(mjd_begin, mjd_end))

    # AR first get the correct structure
    reffn = os.path.join(os.getenv("DESI_SURVEYOPS"), "mtl", "main", "ToO", "ToO.ecsv")
    dref = Table.read(reffn)

    # AR read input file
    targfn = os.path.join(args.targdir, "tertiary-targets-{:04d}.fits".format(args.prognum))
    if not os.path.isfile(targfn):
        msg = "missing {}; exiting".format(targfn)
        log.error(msg)
        raise IOerror(msg)
    targ = Table.read(targfn)
    log.info("reading {} targets from {}".format(len(targ), targfn))

    # AR check all required keys are there
    miss_keys = []
    for key in req_keys:
        if key not in targ.dtype.names:
            miss_keys.append(key)
    if len(miss_keys) > 0:
        msg = "{} keys are missing from {}; exiting".format(
            ",".join(miss_keys), targfn
        )
        log.error(msg)
        raise IOError(msg)

    # AR restrict to targets in the tile
    tiles = Table()
    tiles["RA"], tiles["DEC"] = [args.tilera], [args.tiledec]
    sel = is_point_in_desi(tiles, targ["RA"], targ["DEC"])
    ii = np.where(sel)[0]
    log.info(
        "keep {}/{} targets in tile with (tilera,tiledec)={},{}".format(
            len(ii), len(targ), args.tilera, args.tiledec,
        )
    )
    targ = targ[ii]
    ntarg = len(targ)

    # AR build output file
    too = Table()
    for key in dref.dtype.names:
        too[key] = np.zeros_like(dref[key], shape=(ntarg))
    for key in req_keys:
        too[key] = targ[key]
    too["SCND_ORDER"] = ii # AR record the row from the tertiary-targets-{args.prognum}.fits
    too["DESI_TARGET"] = desi_mask[args.desi_mask_name]
    too["SCND_TARGET"] = scnd_mask[args.scnd_mask_name]
    too["OBSCONDITIONS"] = obsconditions[args.obsconditions]
    too["TOO_TYPE"] = "TILE"
    too["TOO_PRIO"] = default["TOO_PRIO"]
    too["OCLAYER"] = args.obsconditions
    too["MJD_BEGIN"] = mjd_begin
    too["MJD_END"] = mjd_end
    too["TIMESTAMP"] = get_utc_date("main")


    # AR TARGETID (possibly overwrite existing one)
    # AR we use args.prognum as BRICKID
    if "TARGETID" in targ.dtype.names:
        log.warning("not using the original TARGETIDs!")
    too["TARGETID"] = encode_targetid(
        release=release, brickid=args.prognum, objid=np.arange(ntarg)
    )

    # AR SUBPRIORITY
    # AR creating it if not present
    if "SUBPRIORITY" in targ.dtype.names:
        log.info("SUBPRIORITY column present in {} -> propagating it".format(targfn))
        too["SUBPRIORITY"] = targ["SUBPRIORITY"]
    else:
        log.info("SUBPRIORITY column not present in {} -> creating it".format(targfn))
        too["SUBPRIORITY"] = np.random.uniform(size=ntarg)


    # AR NUMOBS, NUMOBS_MORE, PRIORITY
    too["NUMOBS"] = 0
    too["NUMOBS_MORE"] = too["NUMOBS_INIT"].copy()
    too["PRIORITY"] = too["PRIORITY_INIT"].copy()

    # AR previous assignment?
    # AR we proceed as follows:
    # AR - each time a target is assigned, we do NUMOBS_MORE-=1 and NUMOBS+=1
    # AR - when NUMOBS_MORE=0, we change PRIORITY to PRIORITY_DONE
    if args.previous_tileids is not None:
        for tileid in args.previous_tileids.split(","):
            tileid = int(tileid)
            # AR first try args.fadir (case where tiles are designed on the same day)
            fn = os.path.join(
                args.fadir,
                "{}".format("{:06d}".format(tileid)[:3]),
                "fiberassign-{:06d}.fits.gz".format(tileid),
            )
            isfn = False
            if os.path.isfile(fn):
                isfn = True
            # AR then try the DESI_TARGET/fiberassign
            else:
                log.inf("no {}".format(fn))
                fn = os.path.join(
                    os.getenv("DESI_TARGET"),
                    "fiberassign",
                    "tiles",
                    "trunk",
                    "{}".format("{:06d}".format(tileid)[:3]),
                    "fiberassign-{:06d}.fits.gz".format(tileid),
                )
                if os.path.isfile(fn):
                    isfn = True
                else:
                    log.info("no {}".format(fn))
            if isfn:
                log.info("reading {}".format(fn))
                # AR identify assigned targets
                prev_d = Table.read(fn, "FIBERASSIGN")
                _, prev_prognum, prev_release, _, _, _ = decode_targetid(prev_d["TARGETID"])
                sel = np.in1d(prev_release, release) & np.in1d(prev_prognum, args.prognum)
                prev_d = prev_d[sel]
                sel = np.in1d(too["TARGETID"], prev_d["TARGETID"])
                # AR update columns
                too["NUMOBS"][sel] += 1
                too["NUMOBS_MORE"][sel] -= 1
                too["NUMOBS_MORE"] = np.clip(too["NUMOBS_MORE"], 0, None)
                log.info(
                    "{} targets were already assigned on TILEID={}".format(
                        sel.sum(), tileid,
                    )
                )
            else:
                log.warning(
                    "no fiberassign-{:06d}.fits.gz file found: skipping this tile".format(
                        tileid
                    )
                )

        # AR now update PRIORITY for NUMOBS_MORE = 0 targets
        sel = too["NUMOBS_MORE"] == 0
        too["PRIORITY"][sel] = targ["PRIORITY_DONE"][sel]
        log.info("PRIORITY updated to PRIORITY_DONE for {} targets".format(sel.sum()))


    # AR store args (we exclude any None argument)
    tmparr = []
    for kwargs in args._get_kwargs():
        if kwargs[1] is not None:
            tmparr += ["--{} {}".format(kwargs[0], kwargs[1])]
    tooargs = " ".join(tmparr)
    log.info("TOOARGS = {}".format(tooargs))
    too.meta["TOOARGS"] = tooargs
    too.meta["TARGFN"] = targfn

    # AR write
    too.write(toofn)


if __name__ == "__main__":
    main()
