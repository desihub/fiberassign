#!/usr/bin/env python
"""
Main fiber assignment entry point
"""
import os

import sys

import argparse

from datetime import datetime

from desitarget.targetmask import desi_mask

from fiberassign.utils import GlobalTimers, Logger

from fiberassign.hardware import load_hardware

from fiberassign.tiles import load_tiles

from fiberassign.gfa import get_gfa_targets

from fiberassign.targets import (str_to_target_type, TARGET_TYPE_SCIENCE,
                                 TARGET_TYPE_SKY, TARGET_TYPE_STANDARD,
                                 TARGET_TYPE_SAFE, Targets, TargetsAvailable,
                                 TargetTree, FibersAvailable,
                                 load_target_file,
                                 get_sciencemask, get_stdmask, get_skymask,
                                 get_safemask, get_excludemask
                                 )

from fiberassign.assign import (Assignment, write_assignment_fits, result_path)


def main():
    log = Logger.get()
    gt = GlobalTimers.get()
    gt.start("total calculation")

    parser = argparse.ArgumentParser()

    parser.add_argument("--targets", type=str, required=True, action="append",
                        help="Input file with targets of any type.  This "
                        "argument can be specified multiple times (for "
                        "example if standards / skies / science targets are "
                        "in different files).  By default, the DESI_TARGET "
                        "column and bitfield values defined in desitarget "
                        "are used to determine the type of each target.  "
                        "Each filename may be optionally followed by comma "
                        "separated values that will be passed to the "
                        "arguments of the load_target_file() function.  "
                        "See docs for details.")

    parser.add_argument("--gfafile", type=str, required=False, default=None,
                        help="Optional GFA targets FITS file")

    parser.add_argument("--footprint", type=str, required=False, default=None,
                        help="Optional FITS file defining the footprint.  If"
                        " not specified, the default footprint from desimodel"
                        " is used.")

    parser.add_argument("--tiles", type=str, required=False, default=None,
                        help="Optional text file containing a subset of the"
                        " tile IDs to use in the footprint, one ID per line."
                        " Default uses all tiles in the footprint.")

    parser.add_argument("--positioners", type=str, required=False,
                        default=None,
                        help="Optional FITS file describing the fiber "
                        "positioner locations.  Default uses the file from "
                        "desimodel.")

    parser.add_argument("--status", type=str, required=False, default=None,
                        help="Optional fiber status file in astropy ECSV "
                        "format.  Default treats all fibers as good.")

    parser.add_argument("--rundate", type=str, required=False, default=None,
                        help="Optional date to simulate for this run of "
                        "fiber assignment, used with the fiber status file "
                        "to determine which fibers currently have problems.  "
                        "Default uses the current date.  Format is "
                        "YYYY-MM-DDTHH:mm:ss in UTC time.")

    parser.add_argument("--dir", type=str, required=False, default=None,
                        help="Output directory.")

    parser.add_argument("--prefix", type=str, required=False,
                        default="fiberassign_",
                        help="Prefix of each file (before the <tile>.fits).")

    parser.add_argument("--split", required=False, default=False,
                        action="store_true",
                        help="Split output into tile prefix directories.")

    parser.add_argument("--standards_per_petal", type=int, required=False,
                        default=10, help="Required number of standards per"
                        " petal")

    parser.add_argument("--sky_per_petal", type=int, required=False,
                        default=40, help="Required number of sky targets per"
                        " petal")

    parser.add_argument("--write_all_targets", required=False, default=False,
                        action="store_true",
                        help="When writing target properties, write data "
                        "for all available targets, not just those which are "
                        "assigned.  This is convenient, but increases the "
                        "write time and the file size.")

    parser.add_argument("--overwrite", required=False, default=False,
                        action="store_true",
                        help="Overwrite any pre-existing output files")

    parser.add_argument("--sciencemask", required=False,
                        default=get_sciencemask(),
                        help="Default DESI_TARGET mask to use for science "
                             "targets")

    parser.add_argument("--stdmask", required=False,
                        default=get_stdmask(),
                        help="Default DESI_TARGET mask to use for stdstar "
                             "targets")

    parser.add_argument("--skymask", required=False,
                        default=get_skymask(),
                        help="Default DESI_TARGET mask to use for sky targets")

    parser.add_argument("--safemask", required=False,
                        default=get_safemask(),
                        help="Default DESI_TARGET mask to use for safe "
                        "backup targets")

    parser.add_argument("--excludemask", required=False,
                        default=get_excludemask(),
                        help="Default DESI_TARGET mask to exclude from "
                        "any assignments")

    args = parser.parse_args()

    # Allow sciencemask, stdmask, etc. to be int or string
    if type(args.sciencemask) == str:
        args.sciencemask = desi_mask.mask(args.sciencemask.replace(",", "|"))

    if type(args.stdmask) == str:
        args.stdmask = desi_mask.mask(args.stdmask.replace(",", "|"))

    if type(args.skymask) == str:
        args.skymask = desi_mask.mask(args.skymask.replace(",", "|"))

    if type(args.safemask) == str:
        args.safemask = desi_mask.mask(args.safemask.replace(",", "|"))

    if type(args.excludemask) == str:
        args.excludemask = desi_mask.mask(args.excludemask.replace(",", "|"))

    log.info("sciencemask {}".format(
        " ".join(desi_mask.names(args.sciencemask))))
    log.info("stdmask     {}".format(" ".join(desi_mask.names(args.stdmask))))
    log.info("skymask     {}".format(" ".join(desi_mask.names(args.skymask))))
    log.info("safemask    {}".format(" ".join(desi_mask.names(args.safemask))))
    log.info("excludemask {}".format(
        " ".join(desi_mask.names(args.excludemask))))

    # Get run date
    rundate = None
    if args.rundate is None:
        rundate = datetime.utcnow()
    else:
        rundate = datetime.strptime(args.rundate, "%Y-%m-%dT%H:%M:%S")

    # Set output directory
    out_dir = args.dir
    if out_dir is None:
        rdstr = rundate.isoformat("T", "seconds")
        out_dir = "out_fiberassign_{}".format(rdstr)

    # Read hardware properties
    hw = load_hardware(fiberpos_file=args.positioners, rundate=args.rundate,
                       status_file=args.status)

    # Read tiles we are using
    tileselect = None
    if args.tiles is not None:
        tileselect = list()
        with open(args.tiles, "r") as f:
            for line in f:
                # Try to convert the first column to an integer.
                try:
                    tileselect.append(int(line.split()[0]))
                except ValueError:
                    pass
    tiles = load_tiles(hw, tiles_file=args.footprint, select=tileselect)

    # Before doing significant calculations, check for pre-existing files
    if not args.overwrite:
        for tileid in tiles.id:
            outfile = result_path(tileid, dir=args.dir,
                                  prefix=args.prefix, split=args.split)
            if os.path.exists(outfile):
                outdir = os.path.split(outfile)[0]
                log.error("Output files already exist in {}".format(outdir))
                log.error("either remove them or use --overwrite")
                sys.exit(1)

    # Create empty target list
    tgs = Targets()

    # Append each input target file
    for tgarg in args.targets:
        tgprops = tgarg.split(",")
        tgfile = tgprops[0]
        typeforce = None
        if len(tgprops) > 1:
            # we are forcing the target type for this file
            typeforce = str_to_target_type(tgprops[1])
        load_target_file(tgs, tgfile, typeforce=typeforce,
                         sciencemask=args.sciencemask,
                         stdmask=args.stdmask,
                         skymask=args.skymask,
                         safemask=args.safemask,
                         excludemask=args.excludemask)

    # Create a hierarchical triangle mesh lookup of the targets positions
    tree = TargetTree(tgs)

    # Compute the targets available to each fiber for each tile.
    tgsavail = TargetsAvailable(tgs, tiles, tree)

    # Free the tree
    del tree

    # Compute the fibers on all tiles available for each target and sky
    favail = FibersAvailable(tgsavail)

    # Create assignment object
    asgn = Assignment(tgs, tgsavail, favail)

    # First-pass assignment of science targets
    asgn.assign_unused(TARGET_TYPE_SCIENCE)

    # Redistribute science targets across available petals
    asgn.redistribute_science()

    # Assign standards, 10 per petal
    asgn.assign_unused(TARGET_TYPE_STANDARD, args.standards_per_petal)
    asgn.assign_force(TARGET_TYPE_STANDARD, args.standards_per_petal)

    # Assign sky to unused fibers, up to 40 per petal
    asgn.assign_unused(TARGET_TYPE_SKY, args.sky_per_petal)
    asgn.assign_force(TARGET_TYPE_SKY, args.sky_per_petal)

    # If there are any unassigned fibers, try to place them somewhere.
    asgn.assign_unused(TARGET_TYPE_SCIENCE)
    asgn.assign_unused(TARGET_TYPE_SKY)

    # NOTE:  This was removed since we are treating BAD_SKY as science targets
    # with very low priority.
    #
    # # Assign safe location to unused fibers (no maximum).  There should
    # # always be at least one safe location (i.e. "BAD_SKY") for each fiber.
    # # So after this is run every fiber should be assigned to something.
    # asgn.assign_unused(TARGET_TYPE_SAFE)

    # Assign sky monitor fibers
    asgn.assign_unused(TARGET_TYPE_SKY, -1, "ETC")

    gt.stop("total calculation")
    gt.start("total write output")

    # Make sure that output directory exists
    if not os.path.isdir(out_dir):
        os.makedirs(out_dir)

    # Optionally get GFA targets
    gfa_targets = None
    if args.gfafile is not None:
        gfa_targets = get_gfa_targets(tiles, args.gfafile)

    # Write output
    write_assignment_fits(tiles, asgn, out_dir=out_dir,
                          out_prefix=args.prefix, split_dir=args.split,
                          all_targets=args.write_all_targets,
                          gfa_targets=gfa_targets, overwrite=args.overwrite)

    gt.stop("total write output")

    gt.report()

    return


if __name__ == "__main__":
    main()
